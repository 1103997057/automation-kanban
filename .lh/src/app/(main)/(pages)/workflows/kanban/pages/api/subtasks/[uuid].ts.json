{
    "sourceFile": "src/app/(main)/(pages)/workflows/kanban/pages/api/subtasks/[uuid].ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1737791328445,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1737791753429,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,54 +1,67 @@\n // Next.js API route support: https://nextjs.org/docs/api-routes/introduction\r\n import type { NextApiRequest, NextApiResponse } from 'next';\r\n import { prisma } from '../../../utils/db';\r\n import { validate } from 'uuid';\r\n-import { getSession } from 'next-auth/react';\r\n-import { Session } from 'next-auth';\r\n+import { auth } from '@clerk/nextjs/server';\r\n \r\n export default async function handler(req: NextApiRequest, res: NextApiResponse) {\r\n-    const session = await getSession({ req });\r\n-    if (!session) {\r\n+    // Use Clerk's auth to get the authenticated user\r\n+    const { userId } = auth();\r\n+\r\n+    if (!userId) {\r\n         return res.status(401).end('Unauthorized');\r\n     }\r\n+\r\n     if (!req.query.uuid || !validate(req.query.uuid.toString())) {\r\n         return res.status(400).end('Invalid subtask UUID');\r\n     }\r\n+\r\n     switch (req.method) {\r\n         case 'PUT': {\r\n-            return await updateSubtask(req, res, session);\r\n+            return await updateSubtask(req, res, userId);\r\n         }\r\n         default:\r\n             res.status(405).end('Method not allowed');\r\n             break;\r\n     }\r\n }\r\n \r\n-const updateSubtask = async (req: NextApiRequest, res: NextApiResponse, session: Session) => {\r\n+const updateSubtask = async (req: NextApiRequest, res: NextApiResponse, userId: string) => {\r\n     const subtaskUUID = req.query.uuid!.toString();\r\n+\r\n+    // Find the subtask that matches the UUID and belongs to the authenticated user\r\n     const currentSubtaskData = await prisma.subtask.findFirst({\r\n         where: {\r\n             uuid: subtaskUUID,\r\n-            userId: session.user.id,\r\n+            userId: userId, // Use Clerk's userId to validate ownership\r\n         },\r\n     });\r\n+\r\n+    if (!currentSubtaskData) {\r\n+        return res.status(404).end('Subtask not found');\r\n+    }\r\n+\r\n     const { name, completed } = req.body;\r\n+\r\n     if (typeof name === 'undefined' && typeof completed === 'undefined') {\r\n         return res.status(400).end('No data to update');\r\n\\ No newline at end of file\n     }\r\n \r\n-    if (!currentSubtaskData) {\r\n-        return res.status(404).end('Subtask not found');\r\n-    }\r\n-\r\n     const newSubtaskData = {\r\n         name: typeof name === 'string' ? name : currentSubtaskData.name,\r\n         completed: typeof completed === 'boolean' ? completed : currentSubtaskData.completed,\r\n     };\r\n-    const response = await prisma.subtask.update({\r\n-        where: {\r\n-            uuid: subtaskUUID,\r\n-        },\r\n-        data: newSubtaskData,\r\n-    });\r\n-    return res.status(200).json(response);\r\n-};\n+\r\n+    try {\r\n+        const response = await prisma.subtask.update({\r\n+            where: {\r\n+                uuid: subtaskUUID,\r\n+            },\r\n+            data: newSubtaskData,\r\n+        });\r\n+        return res.status(200).json(response);\r\n+    } catch (error: any) {\r\n+        console.error(error);\r\n+        return res.status(500).end('Something went wrong');\r\n+    }\r\n+};\r\n"
                }
            ],
            "date": 1737791328445,
            "name": "Commit-0",
            "content": "// Next.js API route support: https://nextjs.org/docs/api-routes/introduction\r\nimport type { NextApiRequest, NextApiResponse } from 'next';\r\nimport { prisma } from '../../../utils/db';\r\nimport { validate } from 'uuid';\r\nimport { getSession } from 'next-auth/react';\r\nimport { Session } from 'next-auth';\r\n\r\nexport default async function handler(req: NextApiRequest, res: NextApiResponse) {\r\n    const session = await getSession({ req });\r\n    if (!session) {\r\n        return res.status(401).end('Unauthorized');\r\n    }\r\n    if (!req.query.uuid || !validate(req.query.uuid.toString())) {\r\n        return res.status(400).end('Invalid subtask UUID');\r\n    }\r\n    switch (req.method) {\r\n        case 'PUT': {\r\n            return await updateSubtask(req, res, session);\r\n        }\r\n        default:\r\n            res.status(405).end('Method not allowed');\r\n            break;\r\n    }\r\n}\r\n\r\nconst updateSubtask = async (req: NextApiRequest, res: NextApiResponse, session: Session) => {\r\n    const subtaskUUID = req.query.uuid!.toString();\r\n    const currentSubtaskData = await prisma.subtask.findFirst({\r\n        where: {\r\n            uuid: subtaskUUID,\r\n            userId: session.user.id,\r\n        },\r\n    });\r\n    const { name, completed } = req.body;\r\n    if (typeof name === 'undefined' && typeof completed === 'undefined') {\r\n        return res.status(400).end('No data to update');\r\n    }\r\n\r\n    if (!currentSubtaskData) {\r\n        return res.status(404).end('Subtask not found');\r\n    }\r\n\r\n    const newSubtaskData = {\r\n        name: typeof name === 'string' ? name : currentSubtaskData.name,\r\n        completed: typeof completed === 'boolean' ? completed : currentSubtaskData.completed,\r\n    };\r\n    const response = await prisma.subtask.update({\r\n        where: {\r\n            uuid: subtaskUUID,\r\n        },\r\n        data: newSubtaskData,\r\n    });\r\n    return res.status(200).json(response);\r\n};"
        }
    ]
}