{
    "sourceFile": "src/app/(main)/(pages)/workflows/kanban/pages/api/tasks/[uuid].ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 3,
            "patches": [
                {
                    "date": 1737791391307,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1737792842773,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,29 +2,28 @@\n import type { NextApiRequest, NextApiResponse } from 'next';\r\n import { prisma } from '../../../utils/db';\r\n import { validate, v4 as uuidv4 } from 'uuid';\r\n import { Subtask } from '@/types';\r\n-import { getSession } from 'next-auth/react';\r\n-import { Session } from 'next-auth';\r\n+import { getAuth } from '@clerk/nextjs/server';\r\n \r\n export default async function handler(req: NextApiRequest, res: NextApiResponse) {\r\n-    const session = await getSession({ req });\r\n-    if (!session) {\r\n+    const { userId } = getAuth(req);\r\n+    if (!userId) {\r\n         return res.status(401).end('Unauthorized');\r\n     }\r\n \r\n     if (!req.query.uuid || !validate(req.query.uuid.toString())) {\r\n         return res.status(400).end('Invalid board UUID');\r\n     }\r\n     switch (req.method) {\r\n         case 'DELETE': {\r\n-            return await deleteTask(req, res, session);\r\n+            return await deleteTask(req, res, userId);\r\n         }\r\n         case 'GET': {\r\n-            return await getTask(req, res, session);\r\n+            return await getTask(req, res, userId);\r\n         }\r\n         case 'PUT': {\r\n-            return await updateTask(req, res, session);\r\n+            return await updateTask(req, res, userId);\r\n         }\r\n         default:\r\n             res.status(405).end('Method not allowed');\r\n             break;\r\n@@ -58,9 +57,9 @@\n         },\r\n     });\r\n };\r\n \r\n-const updateTaskData = (taskUUID: string, taskData: OptionalTaskData, subtasksToDelete: string[], session: Session) => {\r\n+const updateTaskData = (taskUUID: string, taskData: OptionalTaskData, subtasksToDelete: string[], userId: string) => {\r\n     const { subtasks, ...data } = taskData;\r\n     return prisma.$transaction(async () => {\r\n         if (subtasksToDelete.length > 0) {\r\n             await prisma.subtask.deleteMany({\r\n@@ -82,9 +81,9 @@\n                     },\r\n                     create: {\r\n                         uuid: subtask.uuid,\r\n                         name: subtask.name,\r\n-                        userId: session.user.id,\r\n+                        userId: userId,\r\n                         task: {\r\n                             connect: {\r\n                                 uuid: taskUUID,\r\n                             },\r\n@@ -143,18 +142,18 @@\n     }\r\n     return columnsAreValid;\r\n };\r\n \r\n-const getTask = async (req: NextApiRequest, res: NextApiResponse, session: Session) => {\r\n+const getTask = async (req: NextApiRequest, res: NextApiResponse, userId: string) => {\r\n     const taskUUID = req.query.uuid?.toString();\r\n     if (!taskUUID) {\r\n         return res.status(400).end('Task uuid is required');\r\n     }\r\n     try {\r\n         const task = await prisma.task.findFirst({\r\n             where: {\r\n                 uuid: taskUUID,\r\n-                userId: session.user.id,\r\n+                userId: userId,\r\n             },\r\n             include: {\r\n                 subtasks: {\r\n                     orderBy: {\r\n@@ -173,17 +172,17 @@\n         res.status(500).json({ error: 'Something went wrong' });\r\n     }\r\n };\r\n \r\n-const deleteTask = async (req: NextApiRequest, res: NextApiResponse, session: Session) => {\r\n+const deleteTask = async (req: NextApiRequest, res: NextApiResponse, userId: string) => {\r\n     const taskUUID = req.query.uuid?.toString();\r\n     if (!taskUUID) {\r\n         return res.status(400).end('Task uuid is required');\r\n     }\r\n     const taskData = await prisma.task.findFirst({\r\n         where: {\r\n             uuid: taskUUID,\r\n-            userId: session.user.id,\r\n+            userId: userId,\r\n         },\r\n     });\r\n     if (!taskData) {\r\n         return res.status(404).end('Task not found');\r\n@@ -203,9 +202,9 @@\n         res.status(500).json({ error: 'Something went wrong' });\r\n     }\r\n };\r\n \r\n-const updateTask = async (req: NextApiRequest, res: NextApiResponse, session: Session) => {\r\n+const updateTask = async (req: NextApiRequest, res: NextApiResponse, userId: string) => {\r\n     const taskUUID = req.query.uuid?.toString();\r\n     if (!taskUUID) {\r\n         return res.status(400).end('Task uuid is required');\r\n     }\r\n@@ -215,9 +214,9 @@\n     }\r\n     const currentTaskData = await prisma.task.findFirst({\r\n         where: {\r\n             uuid: taskUUID,\r\n-            userId: session.user.id,\r\n+            userId: userId,\r\n         },\r\n         include: {\r\n             subtasks: true,\r\n         },\r\n@@ -234,11 +233,10 @@\n                   where: { uuid: column_uuid || currentTaskData.column_uuid },\r\n                   include: { tasks: true },\r\n               })\r\n             : null;\r\n-    let movingToEndOfColumn = false; // No need to shift the position of other tasks if true;\r\n+    let movingToEndOfColumn = false;\r\n \r\n-    // Check which subtasks are being deleted\r\n     const subtasksToDelete: string[] = [];\r\n     if (Array.isArray(subtasks)) {\r\n         for (const subtask of currentTaskData.subtasks) {\r\n             const found = subtasks.find((s: Subtask) => s.uuid === subtask.uuid);\r\n@@ -246,9 +244,8 @@\n                 subtasksToDelete.push(subtask.uuid);\r\n             }\r\n         }\r\n     }\r\n-    // Create a new array of columns\r\n     for (const subtask of subtasks ?? []) {\r\n         if (!subtask.uuid) {\r\n             subtask.uuid = uuidv4();\r\n         }\r\n@@ -257,9 +254,8 @@\n     if (position) {\r\n         if (!(typeof position === 'number' && Number.isInteger(position) && !isNaN(position))) {\r\n             return res.status(400).end('Position must be an integer');\r\n         }\r\n-        // Check if position is valid and within accepted range\r\n         if (!column) {\r\n             return res.status(404).end('Column not found');\r\n         }\r\n         if (position < 0) {\r\n@@ -279,25 +275,24 @@\n     };\r\n \r\n     await prisma.$transaction(async () => {\r\n         if (!columnChanged && !positionChanged) {\r\n-            await updateTaskData(taskUUID, newTaskData, subtasksToDelete, session);\r\n+            await updateTaskData(taskUUID, newTaskData, subtasksToDelete, userId);\r\n             return res.status(200).end('Task updated');\r\n         }\r\n         if (columnChanged && !column) {\r\n             return res.status(404).end('Column not found');\r\n         }\r\n-        if (columnChanged && !positionChanged) newTaskData.position = column!.tasks.length; // If position is not set, move to end of column\r\n+        if (columnChanged && !positionChanged) newTaskData.position = column!.tasks.length;\r\n         await decrementHigherPositions(currentTaskData.column_uuid, currentTaskData.position);\r\n         if (positionChanged && !movingToEndOfColumn) {\r\n             await incrementFromPosition(columnChanged ? column_uuid : currentTaskData.column_uuid, position);\r\n         }\r\n-        await updateTaskData(taskUUID, newTaskData, subtasksToDelete, session);\r\n+        await updateTaskData(taskUUID, newTaskData, subtasksToDelete, userId);\r\n         const dataAfterUpdateIsValid = await validateColumns(\r\n             columnChanged ? [column_uuid, currentTaskData.column_uuid] : [currentTaskData.column_uuid]\r\n         );\r\n         if (!dataAfterUpdateIsValid) {\r\n-            console.log('FUCKUP!');\r\n             throw new Error('Invalid position of tasks after update');\r\n         }\r\n         return res.status(200).end('Task updated');\r\n     });\r\n@@ -308,5 +303,5 @@\n     description?: string;\r\n     column_uuid?: string;\r\n     subtasks?: Subtask[];\r\n     position?: number;\r\n-};\n\\ No newline at end of file\n+};\r\n"
                },
                {
                    "date": 1740898468449,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,25 +5,25 @@\n import { Subtask } from '@/types';\r\n import { getAuth } from '@clerk/nextjs/server';\r\n \r\n export default async function handler(req: NextApiRequest, res: NextApiResponse) {\r\n-    const { userId } = getAuth(req);\r\n-    if (!userId) {\r\n+    const { userId:clerkId } = getAuth(req);\r\n+    if (!clerkId) {\r\n         return res.status(401).end('Unauthorized');\r\n     }\r\n \r\n     if (!req.query.uuid || !validate(req.query.uuid.toString())) {\r\n         return res.status(400).end('Invalid board UUID');\r\n     }\r\n     switch (req.method) {\r\n         case 'DELETE': {\r\n-            return await deleteTask(req, res, userId);\r\n+            return await deleteTask(req, res, clerkId);\r\n         }\r\n         case 'GET': {\r\n-            return await getTask(req, res, userId);\r\n+            return await getTask(req, res, clerkId);\r\n         }\r\n         case 'PUT': {\r\n-            return await updateTask(req, res, userId);\r\n+            return await updateTask(req, res, clerkId);\r\n         }\r\n         default:\r\n             res.status(405).end('Method not allowed');\r\n             break;\r\n@@ -81,9 +81,9 @@\n                     },\r\n                     create: {\r\n                         uuid: subtask.uuid,\r\n                         name: subtask.name,\r\n-                        userId: userId,\r\n+                        clerkId: userId,\r\n                         task: {\r\n                             connect: {\r\n                                 uuid: taskUUID,\r\n                             },\r\n@@ -151,9 +151,9 @@\n     try {\r\n         const task = await prisma.task.findFirst({\r\n             where: {\r\n                 uuid: taskUUID,\r\n-                userId: userId,\r\n+                clerkId: userId,\r\n             },\r\n             include: {\r\n                 subtasks: {\r\n                     orderBy: {\r\n@@ -180,9 +180,9 @@\n     }\r\n     const taskData = await prisma.task.findFirst({\r\n         where: {\r\n             uuid: taskUUID,\r\n-            userId: userId,\r\n+            clerkId: userId,\r\n         },\r\n     });\r\n     if (!taskData) {\r\n         return res.status(404).end('Task not found');\r\n@@ -214,9 +214,9 @@\n     }\r\n     const currentTaskData = await prisma.task.findFirst({\r\n         where: {\r\n             uuid: taskUUID,\r\n-            userId: userId,\r\n+            clerkId: userId,\r\n         },\r\n         include: {\r\n             subtasks: true,\r\n         },\r\n@@ -267,9 +267,9 @@\n         }\r\n     }\r\n     const newTaskData: OptionalTaskData = {\r\n         name: name || currentTaskData.name,\r\n-        description: typeof description === undefined ? currentTaskData.description : description,\r\n+        description: typeof description === \"undefined\" ? currentTaskData.description : description,\r\n         column_uuid: column_uuid || currentTaskData.column_uuid,\r\n         subtasks: subtasks || currentTaskData.subtasks,\r\n         position: position !== undefined ? position : currentTaskData.position,\r\n     };\r\n"
                },
                {
                    "date": 1740916023269,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,303 +5,214 @@\n import { Subtask } from '@/types';\r\n import { getAuth } from '@clerk/nextjs/server';\r\n \r\n export default async function handler(req: NextApiRequest, res: NextApiResponse) {\r\n-    const { userId:clerkId } = getAuth(req);\r\n+    const { userId: clerkId } = getAuth(req);\r\n     if (!clerkId) {\r\n         return res.status(401).end('Unauthorized');\r\n     }\r\n \r\n-    if (!req.query.uuid || !validate(req.query.uuid.toString())) {\r\n-        return res.status(400).end('Invalid board UUID');\r\n+    const taskUUID = req.query.uuid?.toString();\r\n+    if (!taskUUID || !validate(taskUUID)) {\r\n+        return res.status(400).end('Invalid task UUID');\r\n     }\r\n-    switch (req.method) {\r\n-        case 'DELETE': {\r\n-            return await deleteTask(req, res, clerkId);\r\n+\r\n+    try {\r\n+        switch (req.method) {\r\n+            case 'DELETE':\r\n+                return await deleteTask(req, res, clerkId, taskUUID);\r\n+            case 'GET':\r\n+                return await getTask(res, clerkId, taskUUID);\r\n+            case 'PUT':\r\n+                return await updateTask(req, res, clerkId, taskUUID);\r\n+            default:\r\n+                return res.status(405).end('Method not allowed');\r\n         }\r\n-        case 'GET': {\r\n-            return await getTask(req, res, clerkId);\r\n-        }\r\n-        case 'PUT': {\r\n-            return await updateTask(req, res, clerkId);\r\n-        }\r\n-        default:\r\n-            res.status(405).end('Method not allowed');\r\n-            break;\r\n+    } catch (error) {\r\n+        console.error(error);\r\n+        return res.status(500).json({ error: 'Internal server error' });\r\n     }\r\n }\r\n \r\n-const decrementHigherPositions = (columnUUID: string, position: number) => {\r\n-    return prisma.task.updateMany({\r\n+const verifyTaskOwnership = async (taskUUID: string, clerkId: string) => {\r\n+    return prisma.task.findFirst({\r\n         where: {\r\n-            column_uuid: columnUUID,\r\n-            position: {\r\n-                gt: position,\r\n+            uuid: taskUUID,\r\n+            column: {\r\n+                board: {\r\n+                    clerkId\r\n+                }\r\n+            }\r\n+        },\r\n+        include: {\r\n+            column: {\r\n+                include: {\r\n+                    board: true\r\n+                }\r\n             },\r\n-        },\r\n-        data: {\r\n-            position: { decrement: 1 },\r\n-        },\r\n+            subtasks: true\r\n+        }\r\n     });\r\n };\r\n \r\n-const incrementFromPosition = (columnUUID: string, position: number) => {\r\n-    return prisma.task.updateMany({\r\n-        where: {\r\n-            column_uuid: columnUUID,\r\n-            position: {\r\n-                gte: position,\r\n-            },\r\n-        },\r\n-        data: {\r\n-            position: { increment: 1 },\r\n-        },\r\n+const getTask = async (res: NextApiResponse, clerkId: string, taskUUID: string) => {\r\n+    const task = await verifyTaskOwnership(taskUUID, clerkId);\r\n+    if (!task) return res.status(404).end('Task not found');\r\n+    \r\n+    return res.status(200).json({\r\n+        ...task,\r\n+        subtasks: task.subtasks.sort((a, b) => a.id - b.id)\r\n     });\r\n };\r\n \r\n-const updateTaskData = (taskUUID: string, taskData: OptionalTaskData, subtasksToDelete: string[], userId: string) => {\r\n-    const { subtasks, ...data } = taskData;\r\n-    return prisma.$transaction(async () => {\r\n-        if (subtasksToDelete.length > 0) {\r\n-            await prisma.subtask.deleteMany({\r\n-                where: {\r\n-                    uuid: {\r\n-                        in: subtasksToDelete,\r\n-                    },\r\n-                },\r\n-            });\r\n-        }\r\n-        if (subtasks) {\r\n-            for (const subtask of subtasks) {\r\n-                await prisma.subtask.upsert({\r\n-                    where: {\r\n-                        uuid: subtask.uuid,\r\n-                    },\r\n-                    update: {\r\n-                        name: subtask.name,\r\n-                    },\r\n-                    create: {\r\n-                        uuid: subtask.uuid,\r\n-                        name: subtask.name,\r\n-                        clerkId: userId,\r\n-                        task: {\r\n-                            connect: {\r\n-                                uuid: taskUUID,\r\n-                            },\r\n-                        },\r\n-                    },\r\n-                });\r\n-            }\r\n-        }\r\n-        await prisma.task.update({\r\n-            where: {\r\n-                uuid: taskUUID,\r\n-            },\r\n-            data,\r\n+const deleteTask = async (req: NextApiRequest, res: NextApiResponse, clerkId: string, taskUUID: string) => {\r\n+    const task = await verifyTaskOwnership(taskUUID, clerkId);\r\n+    if (!task) return res.status(404).end('Task not found');\r\n+  \r\n+    try {\r\n+      await prisma.$transaction(async (prisma) => {\r\n+        await prisma.task.delete({\r\n+          where: { uuid: taskUUID }\r\n         });\r\n-    });\r\n-};\r\n-\r\n-const validateTaskUpdateData = (taskData: any) => {\r\n-    if (Object.keys(taskData).length === 0) {\r\n-        return 'No data to update';\r\n+        await prisma.task.updateMany({\r\n+          where: {\r\n+            column_uuid: task.column_uuid,\r\n+            position: { gt: task.position }\r\n+          },\r\n+          data: { position: { decrement: 1 } }\r\n+        });\r\n+      });\r\n+      return res.status(200).end('Task deleted');\r\n+    } catch (e) {\r\n+      console.error(e);\r\n+      return res.status(500).json({ error: 'Something went wrong' });\r\n     }\r\n-    if (taskData.column && !validate(taskData.column)) {\r\n-        return 'Invalid column UUID';\r\n-    }\r\n-    if (taskData.position && typeof taskData.position !== 'number') {\r\n-        return 'Invalid position';\r\n-    }\r\n-    if (taskData.name && typeof taskData.name !== 'string') {\r\n-        return 'Invalid name';\r\n-    }\r\n-    if (taskData.description && typeof taskData.description !== 'string') {\r\n-        return 'Invalid description';\r\n-    }\r\n-    return;\r\n-};\r\n+  };\r\n \r\n-const validateColumns = async (columnUUIDs: string[]) => {\r\n-    let columnsAreValid = true;\r\n-    for (const columnUUID of columnUUIDs) {\r\n-        const tasks = await prisma.task.findMany({\r\n-            where: {\r\n-                column_uuid: columnUUID,\r\n-            },\r\n-            orderBy: {\r\n-                position: 'asc',\r\n-            },\r\n-        });\r\n-        let position = 0;\r\n-        for (const task of tasks) {\r\n-            if (task.position !== position) {\r\n-                columnsAreValid = false;\r\n-                break;\r\n-            }\r\n-            position++;\r\n+  const updateTask = async (\r\n+    req: NextApiRequest,\r\n+    res: NextApiResponse,\r\n+    clerkId: string,\r\n+    taskUUID: string\r\n+) => {\r\n+    const task = await verifyTaskOwnership(taskUUID, clerkId);\r\n+    if (!task) return res.status(404).end('Task not found');\r\n+\r\n+    const { error, data } = validateTaskData(req.body, task);\r\n+    if (error || !data) return res.status(400).end(error || 'Invalid data');\r\n+\r\n+    await prisma.$transaction(async (tx) => {\r\n+        if (data.positionChanged) {\r\n+            await decrementHigherPositions(tx, task.column_uuid, task.position);\r\n         }\r\n-    }\r\n-    return columnsAreValid;\r\n-};\r\n \r\n-const getTask = async (req: NextApiRequest, res: NextApiResponse, userId: string) => {\r\n-    const taskUUID = req.query.uuid?.toString();\r\n-    if (!taskUUID) {\r\n-        return res.status(400).end('Task uuid is required');\r\n-    }\r\n-    try {\r\n-        const task = await prisma.task.findFirst({\r\n-            where: {\r\n-                uuid: taskUUID,\r\n-                clerkId: userId,\r\n-            },\r\n-            include: {\r\n-                subtasks: {\r\n-                    orderBy: {\r\n-                        id: 'asc',\r\n-                    },\r\n-                },\r\n-            },\r\n-        });\r\n-        if (!task) {\r\n-            res.status(404).end('Task not found');\r\n-        } else {\r\n-            res.status(200).json(task);\r\n+        if (data.newColumn || data.positionChanged) {\r\n+            await incrementFromPosition(\r\n+                tx,\r\n+                data.newColumn || task.column_uuid,\r\n+                data.position\r\n+            );\r\n         }\r\n-    } catch (e) {\r\n-        console.error(e);\r\n-        res.status(500).json({ error: 'Something went wrong' });\r\n-    }\r\n+\r\n+        await updateTaskContents(tx, taskUUID, data);\r\n+    });\r\n+\r\n+    return res.status(200).end('Task updated');\r\n };\r\n-\r\n-const deleteTask = async (req: NextApiRequest, res: NextApiResponse, userId: string) => {\r\n-    const taskUUID = req.query.uuid?.toString();\r\n-    if (!taskUUID) {\r\n-        return res.status(400).end('Task uuid is required');\r\n-    }\r\n-    const taskData = await prisma.task.findFirst({\r\n+  \r\n+// Helper functions - Fix transaction handling\r\n+const decrementHigherPositions = async (tx: any, columnUUID: string, position: number) => {\r\n+    await tx.task.updateMany({\r\n         where: {\r\n-            uuid: taskUUID,\r\n-            clerkId: userId,\r\n+            column_uuid: columnUUID,\r\n+            position: { gt: position }\r\n         },\r\n+        data: { position: { decrement: 1 } }\r\n     });\r\n-    if (!taskData) {\r\n-        return res.status(404).end('Task not found');\r\n-    }\r\n-    try {\r\n-        await prisma.$transaction([\r\n-            prisma.task.delete({\r\n-                where: {\r\n-                    uuid: taskUUID,\r\n-                },\r\n-            }),\r\n-            decrementHigherPositions(taskData.column_uuid, taskData.position),\r\n-        ]);\r\n-        res.status(200).end('Task deleted');\r\n-    } catch (e) {\r\n-        console.error(e);\r\n-        res.status(500).json({ error: 'Something went wrong' });\r\n-    }\r\n };\r\n \r\n-const updateTask = async (req: NextApiRequest, res: NextApiResponse, userId: string) => {\r\n-    const taskUUID = req.query.uuid?.toString();\r\n-    if (!taskUUID) {\r\n-        return res.status(400).end('Task uuid is required');\r\n-    }\r\n-    const err = validateTaskUpdateData(req.body);\r\n-    if (err) {\r\n-        return res.status(400).end(err);\r\n-    }\r\n-    const currentTaskData = await prisma.task.findFirst({\r\n+const incrementFromPosition = async (tx: any, columnUUID: string, position: number) => {\r\n+    await tx.task.updateMany({\r\n         where: {\r\n-            uuid: taskUUID,\r\n-            clerkId: userId,\r\n+            column_uuid: columnUUID,\r\n+            position: { gte: position }\r\n         },\r\n-        include: {\r\n-            subtasks: true,\r\n-        },\r\n+        data: { position: { increment: 1 } }\r\n     });\r\n-    if (!currentTaskData) {\r\n-        return res.status(404).end('Task not found');\r\n-    }\r\n-    let { name, description, column_uuid, subtasks, position } = req.body;\r\n-    const columnChanged = !!(column_uuid && column_uuid !== currentTaskData.column_uuid);\r\n-    const positionChanged = !!(position !== undefined && (position !== currentTaskData.position || columnChanged));\r\n-    const column =\r\n-        columnChanged || positionChanged\r\n-            ? await prisma.column.findFirst({\r\n-                  where: { uuid: column_uuid || currentTaskData.column_uuid },\r\n-                  include: { tasks: true },\r\n-              })\r\n-            : null;\r\n-    let movingToEndOfColumn = false;\r\n+};\r\n \r\n-    const subtasksToDelete: string[] = [];\r\n-    if (Array.isArray(subtasks)) {\r\n-        for (const subtask of currentTaskData.subtasks) {\r\n-            const found = subtasks.find((s: Subtask) => s.uuid === subtask.uuid);\r\n-            if (!found) {\r\n-                subtasksToDelete.push(subtask.uuid);\r\n-            }\r\n-        }\r\n+const validateTaskData = (body: any, existingTask: any) => {\r\n+    const { name, description, column_uuid, position, subtasks } = body;\r\n+    const errors = [];\r\n+    \r\n+    if (column_uuid && !validate(column_uuid)) errors.push('Invalid column UUID');\r\n+    if (position !== undefined && (typeof position !== 'number' || position < 0)) {\r\n+        errors.push('Invalid position value');\r\n     }\r\n-    for (const subtask of subtasks ?? []) {\r\n-        if (!subtask.uuid) {\r\n-            subtask.uuid = uuidv4();\r\n-        }\r\n-    }\r\n+    if (name && typeof name !== 'string') errors.push('Invalid name');\r\n+    if (description && typeof description !== 'string') errors.push('Invalid description');\r\n+    \r\n+    if (errors.length > 0) return { error: errors.join(', ') };\r\n \r\n-    if (position) {\r\n-        if (!(typeof position === 'number' && Number.isInteger(position) && !isNaN(position))) {\r\n-            return res.status(400).end('Position must be an integer');\r\n+    return {\r\n+        data: {\r\n+            name: name || existingTask.name,\r\n+            description: description ?? existingTask.description,\r\n+            column_uuid: column_uuid || existingTask.column_uuid,\r\n+            position: position ?? existingTask.position,\r\n+            subtasks: subtasks || existingTask.subtasks,\r\n+            positionChanged: position !== undefined || column_uuid !== undefined,\r\n+            newColumn: column_uuid && column_uuid !== existingTask.column_uuid\r\n         }\r\n-        if (!column) {\r\n-            return res.status(404).end('Column not found');\r\n-        }\r\n-        if (position < 0) {\r\n-            return res.status(400).end('Position cannot be less than 0');\r\n-        }\r\n-        if (position > column.tasks.length || (!columnChanged && position > column.tasks.length - 1)) {\r\n-            position = columnChanged ? column.tasks.length : column.tasks.length - 1;\r\n-            movingToEndOfColumn = true;\r\n-        }\r\n-    }\r\n-    const newTaskData: OptionalTaskData = {\r\n-        name: name || currentTaskData.name,\r\n-        description: typeof description === \"undefined\" ? currentTaskData.description : description,\r\n-        column_uuid: column_uuid || currentTaskData.column_uuid,\r\n-        subtasks: subtasks || currentTaskData.subtasks,\r\n-        position: position !== undefined ? position : currentTaskData.position,\r\n     };\r\n+};\r\n \r\n-    await prisma.$transaction(async () => {\r\n-        if (!columnChanged && !positionChanged) {\r\n-            await updateTaskData(taskUUID, newTaskData, subtasksToDelete, userId);\r\n-            return res.status(200).end('Task updated');\r\n+const updateTaskContents = async (tx: any, taskUUID: string, data: any) => {\r\n+    const { subtasks, ...taskData } = data;\r\n+    const subtasksToDelete = await processSubtasks(tx, taskUUID, subtasks);\r\n+\r\n+    await tx.task.update({\r\n+        where: { uuid: taskUUID },\r\n+        data: {\r\n+            ...taskData,\r\n+            subtasks: {\r\n+                deleteMany: { uuid: { in: subtasksToDelete } }\r\n+            }\r\n         }\r\n-        if (columnChanged && !column) {\r\n-            return res.status(404).end('Column not found');\r\n-        }\r\n-        if (columnChanged && !positionChanged) newTaskData.position = column!.tasks.length;\r\n-        await decrementHigherPositions(currentTaskData.column_uuid, currentTaskData.position);\r\n-        if (positionChanged && !movingToEndOfColumn) {\r\n-            await incrementFromPosition(columnChanged ? column_uuid : currentTaskData.column_uuid, position);\r\n-        }\r\n-        await updateTaskData(taskUUID, newTaskData, subtasksToDelete, userId);\r\n-        const dataAfterUpdateIsValid = await validateColumns(\r\n-            columnChanged ? [column_uuid, currentTaskData.column_uuid] : [currentTaskData.column_uuid]\r\n-        );\r\n-        if (!dataAfterUpdateIsValid) {\r\n-            throw new Error('Invalid position of tasks after update');\r\n-        }\r\n-        return res.status(200).end('Task updated');\r\n     });\r\n+\r\n+    await upsertSubtasks(tx, taskUUID, subtasks);\r\n };\r\n \r\n+const processSubtasks = async (tx: any, taskUUID: string, subtasks: Subtask[]) => {\r\n+    const existingSubtasks = await tx.subtask.findMany({\r\n+        where: { task_uuid: taskUUID }\r\n+    });\r\n+\r\n+    return existingSubtasks\r\n+        .filter((es: Subtask) => !subtasks.some((s) => s.uuid === es.uuid))\r\n+        .map((es: Subtask) => es.uuid);\r\n+};\r\n+\r\n+const upsertSubtasks = async (tx: any, taskUUID: string, subtasks: Subtask[]) => {\r\n+    for (const subtask of subtasks) {\r\n+        await tx.subtask.upsert({\r\n+            where: { uuid: subtask.uuid || '' },\r\n+            update: { name: subtask.name },\r\n+            create: {\r\n+                uuid: subtask.uuid || uuidv4(),\r\n+                name: subtask.name,\r\n+                task_uuid: taskUUID\r\n+            }\r\n+        });\r\n+    }\r\n+};\r\n+\r\n type OptionalTaskData = {\r\n     name?: string;\r\n     description?: string;\r\n     column_uuid?: string;\r\n     subtasks?: Subtask[];\r\n     position?: number;\r\n-};\r\n+    positionChanged?: boolean;\r\n+    newColumn?: string;\r\n+};\n\\ No newline at end of file\n"
                }
            ],
            "date": 1737791391307,
            "name": "Commit-0",
            "content": "// Next.js API route support: https://nextjs.org/docs/api-routes/introduction\r\nimport type { NextApiRequest, NextApiResponse } from 'next';\r\nimport { prisma } from '../../../utils/db';\r\nimport { validate, v4 as uuidv4 } from 'uuid';\r\nimport { Subtask } from '@/types';\r\nimport { getSession } from 'next-auth/react';\r\nimport { Session } from 'next-auth';\r\n\r\nexport default async function handler(req: NextApiRequest, res: NextApiResponse) {\r\n    const session = await getSession({ req });\r\n    if (!session) {\r\n        return res.status(401).end('Unauthorized');\r\n    }\r\n\r\n    if (!req.query.uuid || !validate(req.query.uuid.toString())) {\r\n        return res.status(400).end('Invalid board UUID');\r\n    }\r\n    switch (req.method) {\r\n        case 'DELETE': {\r\n            return await deleteTask(req, res, session);\r\n        }\r\n        case 'GET': {\r\n            return await getTask(req, res, session);\r\n        }\r\n        case 'PUT': {\r\n            return await updateTask(req, res, session);\r\n        }\r\n        default:\r\n            res.status(405).end('Method not allowed');\r\n            break;\r\n    }\r\n}\r\n\r\nconst decrementHigherPositions = (columnUUID: string, position: number) => {\r\n    return prisma.task.updateMany({\r\n        where: {\r\n            column_uuid: columnUUID,\r\n            position: {\r\n                gt: position,\r\n            },\r\n        },\r\n        data: {\r\n            position: { decrement: 1 },\r\n        },\r\n    });\r\n};\r\n\r\nconst incrementFromPosition = (columnUUID: string, position: number) => {\r\n    return prisma.task.updateMany({\r\n        where: {\r\n            column_uuid: columnUUID,\r\n            position: {\r\n                gte: position,\r\n            },\r\n        },\r\n        data: {\r\n            position: { increment: 1 },\r\n        },\r\n    });\r\n};\r\n\r\nconst updateTaskData = (taskUUID: string, taskData: OptionalTaskData, subtasksToDelete: string[], session: Session) => {\r\n    const { subtasks, ...data } = taskData;\r\n    return prisma.$transaction(async () => {\r\n        if (subtasksToDelete.length > 0) {\r\n            await prisma.subtask.deleteMany({\r\n                where: {\r\n                    uuid: {\r\n                        in: subtasksToDelete,\r\n                    },\r\n                },\r\n            });\r\n        }\r\n        if (subtasks) {\r\n            for (const subtask of subtasks) {\r\n                await prisma.subtask.upsert({\r\n                    where: {\r\n                        uuid: subtask.uuid,\r\n                    },\r\n                    update: {\r\n                        name: subtask.name,\r\n                    },\r\n                    create: {\r\n                        uuid: subtask.uuid,\r\n                        name: subtask.name,\r\n                        userId: session.user.id,\r\n                        task: {\r\n                            connect: {\r\n                                uuid: taskUUID,\r\n                            },\r\n                        },\r\n                    },\r\n                });\r\n            }\r\n        }\r\n        await prisma.task.update({\r\n            where: {\r\n                uuid: taskUUID,\r\n            },\r\n            data,\r\n        });\r\n    });\r\n};\r\n\r\nconst validateTaskUpdateData = (taskData: any) => {\r\n    if (Object.keys(taskData).length === 0) {\r\n        return 'No data to update';\r\n    }\r\n    if (taskData.column && !validate(taskData.column)) {\r\n        return 'Invalid column UUID';\r\n    }\r\n    if (taskData.position && typeof taskData.position !== 'number') {\r\n        return 'Invalid position';\r\n    }\r\n    if (taskData.name && typeof taskData.name !== 'string') {\r\n        return 'Invalid name';\r\n    }\r\n    if (taskData.description && typeof taskData.description !== 'string') {\r\n        return 'Invalid description';\r\n    }\r\n    return;\r\n};\r\n\r\nconst validateColumns = async (columnUUIDs: string[]) => {\r\n    let columnsAreValid = true;\r\n    for (const columnUUID of columnUUIDs) {\r\n        const tasks = await prisma.task.findMany({\r\n            where: {\r\n                column_uuid: columnUUID,\r\n            },\r\n            orderBy: {\r\n                position: 'asc',\r\n            },\r\n        });\r\n        let position = 0;\r\n        for (const task of tasks) {\r\n            if (task.position !== position) {\r\n                columnsAreValid = false;\r\n                break;\r\n            }\r\n            position++;\r\n        }\r\n    }\r\n    return columnsAreValid;\r\n};\r\n\r\nconst getTask = async (req: NextApiRequest, res: NextApiResponse, session: Session) => {\r\n    const taskUUID = req.query.uuid?.toString();\r\n    if (!taskUUID) {\r\n        return res.status(400).end('Task uuid is required');\r\n    }\r\n    try {\r\n        const task = await prisma.task.findFirst({\r\n            where: {\r\n                uuid: taskUUID,\r\n                userId: session.user.id,\r\n            },\r\n            include: {\r\n                subtasks: {\r\n                    orderBy: {\r\n                        id: 'asc',\r\n                    },\r\n                },\r\n            },\r\n        });\r\n        if (!task) {\r\n            res.status(404).end('Task not found');\r\n        } else {\r\n            res.status(200).json(task);\r\n        }\r\n    } catch (e) {\r\n        console.error(e);\r\n        res.status(500).json({ error: 'Something went wrong' });\r\n    }\r\n};\r\n\r\nconst deleteTask = async (req: NextApiRequest, res: NextApiResponse, session: Session) => {\r\n    const taskUUID = req.query.uuid?.toString();\r\n    if (!taskUUID) {\r\n        return res.status(400).end('Task uuid is required');\r\n    }\r\n    const taskData = await prisma.task.findFirst({\r\n        where: {\r\n            uuid: taskUUID,\r\n            userId: session.user.id,\r\n        },\r\n    });\r\n    if (!taskData) {\r\n        return res.status(404).end('Task not found');\r\n    }\r\n    try {\r\n        await prisma.$transaction([\r\n            prisma.task.delete({\r\n                where: {\r\n                    uuid: taskUUID,\r\n                },\r\n            }),\r\n            decrementHigherPositions(taskData.column_uuid, taskData.position),\r\n        ]);\r\n        res.status(200).end('Task deleted');\r\n    } catch (e) {\r\n        console.error(e);\r\n        res.status(500).json({ error: 'Something went wrong' });\r\n    }\r\n};\r\n\r\nconst updateTask = async (req: NextApiRequest, res: NextApiResponse, session: Session) => {\r\n    const taskUUID = req.query.uuid?.toString();\r\n    if (!taskUUID) {\r\n        return res.status(400).end('Task uuid is required');\r\n    }\r\n    const err = validateTaskUpdateData(req.body);\r\n    if (err) {\r\n        return res.status(400).end(err);\r\n    }\r\n    const currentTaskData = await prisma.task.findFirst({\r\n        where: {\r\n            uuid: taskUUID,\r\n            userId: session.user.id,\r\n        },\r\n        include: {\r\n            subtasks: true,\r\n        },\r\n    });\r\n    if (!currentTaskData) {\r\n        return res.status(404).end('Task not found');\r\n    }\r\n    let { name, description, column_uuid, subtasks, position } = req.body;\r\n    const columnChanged = !!(column_uuid && column_uuid !== currentTaskData.column_uuid);\r\n    const positionChanged = !!(position !== undefined && (position !== currentTaskData.position || columnChanged));\r\n    const column =\r\n        columnChanged || positionChanged\r\n            ? await prisma.column.findFirst({\r\n                  where: { uuid: column_uuid || currentTaskData.column_uuid },\r\n                  include: { tasks: true },\r\n              })\r\n            : null;\r\n    let movingToEndOfColumn = false; // No need to shift the position of other tasks if true;\r\n\r\n    // Check which subtasks are being deleted\r\n    const subtasksToDelete: string[] = [];\r\n    if (Array.isArray(subtasks)) {\r\n        for (const subtask of currentTaskData.subtasks) {\r\n            const found = subtasks.find((s: Subtask) => s.uuid === subtask.uuid);\r\n            if (!found) {\r\n                subtasksToDelete.push(subtask.uuid);\r\n            }\r\n        }\r\n    }\r\n    // Create a new array of columns\r\n    for (const subtask of subtasks ?? []) {\r\n        if (!subtask.uuid) {\r\n            subtask.uuid = uuidv4();\r\n        }\r\n    }\r\n\r\n    if (position) {\r\n        if (!(typeof position === 'number' && Number.isInteger(position) && !isNaN(position))) {\r\n            return res.status(400).end('Position must be an integer');\r\n        }\r\n        // Check if position is valid and within accepted range\r\n        if (!column) {\r\n            return res.status(404).end('Column not found');\r\n        }\r\n        if (position < 0) {\r\n            return res.status(400).end('Position cannot be less than 0');\r\n        }\r\n        if (position > column.tasks.length || (!columnChanged && position > column.tasks.length - 1)) {\r\n            position = columnChanged ? column.tasks.length : column.tasks.length - 1;\r\n            movingToEndOfColumn = true;\r\n        }\r\n    }\r\n    const newTaskData: OptionalTaskData = {\r\n        name: name || currentTaskData.name,\r\n        description: typeof description === undefined ? currentTaskData.description : description,\r\n        column_uuid: column_uuid || currentTaskData.column_uuid,\r\n        subtasks: subtasks || currentTaskData.subtasks,\r\n        position: position !== undefined ? position : currentTaskData.position,\r\n    };\r\n\r\n    await prisma.$transaction(async () => {\r\n        if (!columnChanged && !positionChanged) {\r\n            await updateTaskData(taskUUID, newTaskData, subtasksToDelete, session);\r\n            return res.status(200).end('Task updated');\r\n        }\r\n        if (columnChanged && !column) {\r\n            return res.status(404).end('Column not found');\r\n        }\r\n        if (columnChanged && !positionChanged) newTaskData.position = column!.tasks.length; // If position is not set, move to end of column\r\n        await decrementHigherPositions(currentTaskData.column_uuid, currentTaskData.position);\r\n        if (positionChanged && !movingToEndOfColumn) {\r\n            await incrementFromPosition(columnChanged ? column_uuid : currentTaskData.column_uuid, position);\r\n        }\r\n        await updateTaskData(taskUUID, newTaskData, subtasksToDelete, session);\r\n        const dataAfterUpdateIsValid = await validateColumns(\r\n            columnChanged ? [column_uuid, currentTaskData.column_uuid] : [currentTaskData.column_uuid]\r\n        );\r\n        if (!dataAfterUpdateIsValid) {\r\n            console.log('FUCKUP!');\r\n            throw new Error('Invalid position of tasks after update');\r\n        }\r\n        return res.status(200).end('Task updated');\r\n    });\r\n};\r\n\r\ntype OptionalTaskData = {\r\n    name?: string;\r\n    description?: string;\r\n    column_uuid?: string;\r\n    subtasks?: Subtask[];\r\n    position?: number;\r\n};"
        }
    ]
}