{
    "sourceFile": "src/app/(main)/(pages)/workflows/kanban/pages/api/tasks/[uuid].ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1737791391307,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1737792842773,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,29 +2,28 @@\n import type { NextApiRequest, NextApiResponse } from 'next';\r\n import { prisma } from '../../../utils/db';\r\n import { validate, v4 as uuidv4 } from 'uuid';\r\n import { Subtask } from '@/types';\r\n-import { getSession } from 'next-auth/react';\r\n-import { Session } from 'next-auth';\r\n+import { getAuth } from '@clerk/nextjs/server';\r\n \r\n export default async function handler(req: NextApiRequest, res: NextApiResponse) {\r\n-    const session = await getSession({ req });\r\n-    if (!session) {\r\n+    const { userId } = getAuth(req);\r\n+    if (!userId) {\r\n         return res.status(401).end('Unauthorized');\r\n     }\r\n \r\n     if (!req.query.uuid || !validate(req.query.uuid.toString())) {\r\n         return res.status(400).end('Invalid board UUID');\r\n     }\r\n     switch (req.method) {\r\n         case 'DELETE': {\r\n-            return await deleteTask(req, res, session);\r\n+            return await deleteTask(req, res, userId);\r\n         }\r\n         case 'GET': {\r\n-            return await getTask(req, res, session);\r\n+            return await getTask(req, res, userId);\r\n         }\r\n         case 'PUT': {\r\n-            return await updateTask(req, res, session);\r\n+            return await updateTask(req, res, userId);\r\n         }\r\n         default:\r\n             res.status(405).end('Method not allowed');\r\n             break;\r\n@@ -58,9 +57,9 @@\n         },\r\n     });\r\n };\r\n \r\n-const updateTaskData = (taskUUID: string, taskData: OptionalTaskData, subtasksToDelete: string[], session: Session) => {\r\n+const updateTaskData = (taskUUID: string, taskData: OptionalTaskData, subtasksToDelete: string[], userId: string) => {\r\n     const { subtasks, ...data } = taskData;\r\n     return prisma.$transaction(async () => {\r\n         if (subtasksToDelete.length > 0) {\r\n             await prisma.subtask.deleteMany({\r\n@@ -82,9 +81,9 @@\n                     },\r\n                     create: {\r\n                         uuid: subtask.uuid,\r\n                         name: subtask.name,\r\n-                        userId: session.user.id,\r\n+                        userId: userId,\r\n                         task: {\r\n                             connect: {\r\n                                 uuid: taskUUID,\r\n                             },\r\n@@ -143,18 +142,18 @@\n     }\r\n     return columnsAreValid;\r\n };\r\n \r\n-const getTask = async (req: NextApiRequest, res: NextApiResponse, session: Session) => {\r\n+const getTask = async (req: NextApiRequest, res: NextApiResponse, userId: string) => {\r\n     const taskUUID = req.query.uuid?.toString();\r\n     if (!taskUUID) {\r\n         return res.status(400).end('Task uuid is required');\r\n     }\r\n     try {\r\n         const task = await prisma.task.findFirst({\r\n             where: {\r\n                 uuid: taskUUID,\r\n-                userId: session.user.id,\r\n+                userId: userId,\r\n             },\r\n             include: {\r\n                 subtasks: {\r\n                     orderBy: {\r\n@@ -173,17 +172,17 @@\n         res.status(500).json({ error: 'Something went wrong' });\r\n     }\r\n };\r\n \r\n-const deleteTask = async (req: NextApiRequest, res: NextApiResponse, session: Session) => {\r\n+const deleteTask = async (req: NextApiRequest, res: NextApiResponse, userId: string) => {\r\n     const taskUUID = req.query.uuid?.toString();\r\n     if (!taskUUID) {\r\n         return res.status(400).end('Task uuid is required');\r\n     }\r\n     const taskData = await prisma.task.findFirst({\r\n         where: {\r\n             uuid: taskUUID,\r\n-            userId: session.user.id,\r\n+            userId: userId,\r\n         },\r\n     });\r\n     if (!taskData) {\r\n         return res.status(404).end('Task not found');\r\n@@ -203,9 +202,9 @@\n         res.status(500).json({ error: 'Something went wrong' });\r\n     }\r\n };\r\n \r\n-const updateTask = async (req: NextApiRequest, res: NextApiResponse, session: Session) => {\r\n+const updateTask = async (req: NextApiRequest, res: NextApiResponse, userId: string) => {\r\n     const taskUUID = req.query.uuid?.toString();\r\n     if (!taskUUID) {\r\n         return res.status(400).end('Task uuid is required');\r\n     }\r\n@@ -215,9 +214,9 @@\n     }\r\n     const currentTaskData = await prisma.task.findFirst({\r\n         where: {\r\n             uuid: taskUUID,\r\n-            userId: session.user.id,\r\n+            userId: userId,\r\n         },\r\n         include: {\r\n             subtasks: true,\r\n         },\r\n@@ -234,11 +233,10 @@\n                   where: { uuid: column_uuid || currentTaskData.column_uuid },\r\n                   include: { tasks: true },\r\n               })\r\n             : null;\r\n-    let movingToEndOfColumn = false; // No need to shift the position of other tasks if true;\r\n+    let movingToEndOfColumn = false;\r\n \r\n-    // Check which subtasks are being deleted\r\n     const subtasksToDelete: string[] = [];\r\n     if (Array.isArray(subtasks)) {\r\n         for (const subtask of currentTaskData.subtasks) {\r\n             const found = subtasks.find((s: Subtask) => s.uuid === subtask.uuid);\r\n@@ -246,9 +244,8 @@\n                 subtasksToDelete.push(subtask.uuid);\r\n             }\r\n         }\r\n     }\r\n-    // Create a new array of columns\r\n     for (const subtask of subtasks ?? []) {\r\n         if (!subtask.uuid) {\r\n             subtask.uuid = uuidv4();\r\n         }\r\n@@ -257,9 +254,8 @@\n     if (position) {\r\n         if (!(typeof position === 'number' && Number.isInteger(position) && !isNaN(position))) {\r\n             return res.status(400).end('Position must be an integer');\r\n         }\r\n-        // Check if position is valid and within accepted range\r\n         if (!column) {\r\n             return res.status(404).end('Column not found');\r\n         }\r\n         if (position < 0) {\r\n@@ -279,25 +275,24 @@\n     };\r\n \r\n     await prisma.$transaction(async () => {\r\n         if (!columnChanged && !positionChanged) {\r\n-            await updateTaskData(taskUUID, newTaskData, subtasksToDelete, session);\r\n+            await updateTaskData(taskUUID, newTaskData, subtasksToDelete, userId);\r\n             return res.status(200).end('Task updated');\r\n         }\r\n         if (columnChanged && !column) {\r\n             return res.status(404).end('Column not found');\r\n         }\r\n-        if (columnChanged && !positionChanged) newTaskData.position = column!.tasks.length; // If position is not set, move to end of column\r\n+        if (columnChanged && !positionChanged) newTaskData.position = column!.tasks.length;\r\n         await decrementHigherPositions(currentTaskData.column_uuid, currentTaskData.position);\r\n         if (positionChanged && !movingToEndOfColumn) {\r\n             await incrementFromPosition(columnChanged ? column_uuid : currentTaskData.column_uuid, position);\r\n         }\r\n-        await updateTaskData(taskUUID, newTaskData, subtasksToDelete, session);\r\n+        await updateTaskData(taskUUID, newTaskData, subtasksToDelete, userId);\r\n         const dataAfterUpdateIsValid = await validateColumns(\r\n             columnChanged ? [column_uuid, currentTaskData.column_uuid] : [currentTaskData.column_uuid]\r\n         );\r\n         if (!dataAfterUpdateIsValid) {\r\n-            console.log('FUCKUP!');\r\n             throw new Error('Invalid position of tasks after update');\r\n         }\r\n         return res.status(200).end('Task updated');\r\n     });\r\n@@ -308,5 +303,5 @@\n     description?: string;\r\n     column_uuid?: string;\r\n     subtasks?: Subtask[];\r\n     position?: number;\r\n-};\n\\ No newline at end of file\n+};\r\n"
                }
            ],
            "date": 1737791391307,
            "name": "Commit-0",
            "content": "// Next.js API route support: https://nextjs.org/docs/api-routes/introduction\r\nimport type { NextApiRequest, NextApiResponse } from 'next';\r\nimport { prisma } from '../../../utils/db';\r\nimport { validate, v4 as uuidv4 } from 'uuid';\r\nimport { Subtask } from '@/types';\r\nimport { getSession } from 'next-auth/react';\r\nimport { Session } from 'next-auth';\r\n\r\nexport default async function handler(req: NextApiRequest, res: NextApiResponse) {\r\n    const session = await getSession({ req });\r\n    if (!session) {\r\n        return res.status(401).end('Unauthorized');\r\n    }\r\n\r\n    if (!req.query.uuid || !validate(req.query.uuid.toString())) {\r\n        return res.status(400).end('Invalid board UUID');\r\n    }\r\n    switch (req.method) {\r\n        case 'DELETE': {\r\n            return await deleteTask(req, res, session);\r\n        }\r\n        case 'GET': {\r\n            return await getTask(req, res, session);\r\n        }\r\n        case 'PUT': {\r\n            return await updateTask(req, res, session);\r\n        }\r\n        default:\r\n            res.status(405).end('Method not allowed');\r\n            break;\r\n    }\r\n}\r\n\r\nconst decrementHigherPositions = (columnUUID: string, position: number) => {\r\n    return prisma.task.updateMany({\r\n        where: {\r\n            column_uuid: columnUUID,\r\n            position: {\r\n                gt: position,\r\n            },\r\n        },\r\n        data: {\r\n            position: { decrement: 1 },\r\n        },\r\n    });\r\n};\r\n\r\nconst incrementFromPosition = (columnUUID: string, position: number) => {\r\n    return prisma.task.updateMany({\r\n        where: {\r\n            column_uuid: columnUUID,\r\n            position: {\r\n                gte: position,\r\n            },\r\n        },\r\n        data: {\r\n            position: { increment: 1 },\r\n        },\r\n    });\r\n};\r\n\r\nconst updateTaskData = (taskUUID: string, taskData: OptionalTaskData, subtasksToDelete: string[], session: Session) => {\r\n    const { subtasks, ...data } = taskData;\r\n    return prisma.$transaction(async () => {\r\n        if (subtasksToDelete.length > 0) {\r\n            await prisma.subtask.deleteMany({\r\n                where: {\r\n                    uuid: {\r\n                        in: subtasksToDelete,\r\n                    },\r\n                },\r\n            });\r\n        }\r\n        if (subtasks) {\r\n            for (const subtask of subtasks) {\r\n                await prisma.subtask.upsert({\r\n                    where: {\r\n                        uuid: subtask.uuid,\r\n                    },\r\n                    update: {\r\n                        name: subtask.name,\r\n                    },\r\n                    create: {\r\n                        uuid: subtask.uuid,\r\n                        name: subtask.name,\r\n                        userId: session.user.id,\r\n                        task: {\r\n                            connect: {\r\n                                uuid: taskUUID,\r\n                            },\r\n                        },\r\n                    },\r\n                });\r\n            }\r\n        }\r\n        await prisma.task.update({\r\n            where: {\r\n                uuid: taskUUID,\r\n            },\r\n            data,\r\n        });\r\n    });\r\n};\r\n\r\nconst validateTaskUpdateData = (taskData: any) => {\r\n    if (Object.keys(taskData).length === 0) {\r\n        return 'No data to update';\r\n    }\r\n    if (taskData.column && !validate(taskData.column)) {\r\n        return 'Invalid column UUID';\r\n    }\r\n    if (taskData.position && typeof taskData.position !== 'number') {\r\n        return 'Invalid position';\r\n    }\r\n    if (taskData.name && typeof taskData.name !== 'string') {\r\n        return 'Invalid name';\r\n    }\r\n    if (taskData.description && typeof taskData.description !== 'string') {\r\n        return 'Invalid description';\r\n    }\r\n    return;\r\n};\r\n\r\nconst validateColumns = async (columnUUIDs: string[]) => {\r\n    let columnsAreValid = true;\r\n    for (const columnUUID of columnUUIDs) {\r\n        const tasks = await prisma.task.findMany({\r\n            where: {\r\n                column_uuid: columnUUID,\r\n            },\r\n            orderBy: {\r\n                position: 'asc',\r\n            },\r\n        });\r\n        let position = 0;\r\n        for (const task of tasks) {\r\n            if (task.position !== position) {\r\n                columnsAreValid = false;\r\n                break;\r\n            }\r\n            position++;\r\n        }\r\n    }\r\n    return columnsAreValid;\r\n};\r\n\r\nconst getTask = async (req: NextApiRequest, res: NextApiResponse, session: Session) => {\r\n    const taskUUID = req.query.uuid?.toString();\r\n    if (!taskUUID) {\r\n        return res.status(400).end('Task uuid is required');\r\n    }\r\n    try {\r\n        const task = await prisma.task.findFirst({\r\n            where: {\r\n                uuid: taskUUID,\r\n                userId: session.user.id,\r\n            },\r\n            include: {\r\n                subtasks: {\r\n                    orderBy: {\r\n                        id: 'asc',\r\n                    },\r\n                },\r\n            },\r\n        });\r\n        if (!task) {\r\n            res.status(404).end('Task not found');\r\n        } else {\r\n            res.status(200).json(task);\r\n        }\r\n    } catch (e) {\r\n        console.error(e);\r\n        res.status(500).json({ error: 'Something went wrong' });\r\n    }\r\n};\r\n\r\nconst deleteTask = async (req: NextApiRequest, res: NextApiResponse, session: Session) => {\r\n    const taskUUID = req.query.uuid?.toString();\r\n    if (!taskUUID) {\r\n        return res.status(400).end('Task uuid is required');\r\n    }\r\n    const taskData = await prisma.task.findFirst({\r\n        where: {\r\n            uuid: taskUUID,\r\n            userId: session.user.id,\r\n        },\r\n    });\r\n    if (!taskData) {\r\n        return res.status(404).end('Task not found');\r\n    }\r\n    try {\r\n        await prisma.$transaction([\r\n            prisma.task.delete({\r\n                where: {\r\n                    uuid: taskUUID,\r\n                },\r\n            }),\r\n            decrementHigherPositions(taskData.column_uuid, taskData.position),\r\n        ]);\r\n        res.status(200).end('Task deleted');\r\n    } catch (e) {\r\n        console.error(e);\r\n        res.status(500).json({ error: 'Something went wrong' });\r\n    }\r\n};\r\n\r\nconst updateTask = async (req: NextApiRequest, res: NextApiResponse, session: Session) => {\r\n    const taskUUID = req.query.uuid?.toString();\r\n    if (!taskUUID) {\r\n        return res.status(400).end('Task uuid is required');\r\n    }\r\n    const err = validateTaskUpdateData(req.body);\r\n    if (err) {\r\n        return res.status(400).end(err);\r\n    }\r\n    const currentTaskData = await prisma.task.findFirst({\r\n        where: {\r\n            uuid: taskUUID,\r\n            userId: session.user.id,\r\n        },\r\n        include: {\r\n            subtasks: true,\r\n        },\r\n    });\r\n    if (!currentTaskData) {\r\n        return res.status(404).end('Task not found');\r\n    }\r\n    let { name, description, column_uuid, subtasks, position } = req.body;\r\n    const columnChanged = !!(column_uuid && column_uuid !== currentTaskData.column_uuid);\r\n    const positionChanged = !!(position !== undefined && (position !== currentTaskData.position || columnChanged));\r\n    const column =\r\n        columnChanged || positionChanged\r\n            ? await prisma.column.findFirst({\r\n                  where: { uuid: column_uuid || currentTaskData.column_uuid },\r\n                  include: { tasks: true },\r\n              })\r\n            : null;\r\n    let movingToEndOfColumn = false; // No need to shift the position of other tasks if true;\r\n\r\n    // Check which subtasks are being deleted\r\n    const subtasksToDelete: string[] = [];\r\n    if (Array.isArray(subtasks)) {\r\n        for (const subtask of currentTaskData.subtasks) {\r\n            const found = subtasks.find((s: Subtask) => s.uuid === subtask.uuid);\r\n            if (!found) {\r\n                subtasksToDelete.push(subtask.uuid);\r\n            }\r\n        }\r\n    }\r\n    // Create a new array of columns\r\n    for (const subtask of subtasks ?? []) {\r\n        if (!subtask.uuid) {\r\n            subtask.uuid = uuidv4();\r\n        }\r\n    }\r\n\r\n    if (position) {\r\n        if (!(typeof position === 'number' && Number.isInteger(position) && !isNaN(position))) {\r\n            return res.status(400).end('Position must be an integer');\r\n        }\r\n        // Check if position is valid and within accepted range\r\n        if (!column) {\r\n            return res.status(404).end('Column not found');\r\n        }\r\n        if (position < 0) {\r\n            return res.status(400).end('Position cannot be less than 0');\r\n        }\r\n        if (position > column.tasks.length || (!columnChanged && position > column.tasks.length - 1)) {\r\n            position = columnChanged ? column.tasks.length : column.tasks.length - 1;\r\n            movingToEndOfColumn = true;\r\n        }\r\n    }\r\n    const newTaskData: OptionalTaskData = {\r\n        name: name || currentTaskData.name,\r\n        description: typeof description === undefined ? currentTaskData.description : description,\r\n        column_uuid: column_uuid || currentTaskData.column_uuid,\r\n        subtasks: subtasks || currentTaskData.subtasks,\r\n        position: position !== undefined ? position : currentTaskData.position,\r\n    };\r\n\r\n    await prisma.$transaction(async () => {\r\n        if (!columnChanged && !positionChanged) {\r\n            await updateTaskData(taskUUID, newTaskData, subtasksToDelete, session);\r\n            return res.status(200).end('Task updated');\r\n        }\r\n        if (columnChanged && !column) {\r\n            return res.status(404).end('Column not found');\r\n        }\r\n        if (columnChanged && !positionChanged) newTaskData.position = column!.tasks.length; // If position is not set, move to end of column\r\n        await decrementHigherPositions(currentTaskData.column_uuid, currentTaskData.position);\r\n        if (positionChanged && !movingToEndOfColumn) {\r\n            await incrementFromPosition(columnChanged ? column_uuid : currentTaskData.column_uuid, position);\r\n        }\r\n        await updateTaskData(taskUUID, newTaskData, subtasksToDelete, session);\r\n        const dataAfterUpdateIsValid = await validateColumns(\r\n            columnChanged ? [column_uuid, currentTaskData.column_uuid] : [currentTaskData.column_uuid]\r\n        );\r\n        if (!dataAfterUpdateIsValid) {\r\n            console.log('FUCKUP!');\r\n            throw new Error('Invalid position of tasks after update');\r\n        }\r\n        return res.status(200).end('Task updated');\r\n    });\r\n};\r\n\r\ntype OptionalTaskData = {\r\n    name?: string;\r\n    description?: string;\r\n    column_uuid?: string;\r\n    subtasks?: Subtask[];\r\n    position?: number;\r\n};"
        }
    ]
}