{
    "sourceFile": "src/app/(main)/(pages)/workflows/kanban/components/Board/Board.tsx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1737281151803,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1740145848528,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,4 +1,5 @@\n+'use client'\r\n import { FC, useEffect, useRef, useState } from 'react';\r\n import Column from './Column/Column';\r\n import { DragStartEvent, DragEndEvent, DragOverEvent, closestCorners } from '@dnd-kit/core';\r\n import {\r\n"
                }
            ],
            "date": 1737281151803,
            "name": "Commit-0",
            "content": "import { FC, useEffect, useRef, useState } from 'react';\r\nimport Column from './Column/Column';\r\nimport { DragStartEvent, DragEndEvent, DragOverEvent, closestCorners } from '@dnd-kit/core';\r\nimport {\r\n    DndContext,\r\n    useSensor,\r\n    useSensors,\r\n    MouseSensor,\r\n    TouchSensor,\r\n    MeasuringStrategy,\r\n    UniqueIdentifier,\r\n} from '@dnd-kit/core';\r\nimport { arrayMove } from '@dnd-kit/sortable';\r\nimport { Board as BoardT, Columns, Task } from '@/types';\r\nimport { fetcher, randomHexColor } from '../../utils/utils';\r\nimport useSWR from 'swr';\r\nimport { useRouter } from 'next/router';\r\nimport { useBoardsContext } from '../../store/BoardListContext';\r\nimport useInput from '../../hooks/useInput';\r\n\r\nconst validateColumn = (value: string): [boolean, string] => {\r\n    if (!value || value.trim().length < 1) return [false, \"Can't be empty\"];\r\n    if (value.trim().length > 20) return [false, `${value.trim().length}/20`];\r\n    return [true, ''];\r\n};\r\n\r\nconst NewColumnBar: FC<{\r\n    mutateBoard: Function;\r\n    boardUUID: string;\r\n}> = ({ mutateBoard, boardUUID }) => {\r\n    const inputRef = useRef<HTMLInputElement>(null);\r\n    const { mutateBoards } = useBoardsContext();\r\n    const inputHandler = useInput<string>({ validateFn: validateColumn });\r\n\r\n    const submitHandler = (e: React.FormEvent<HTMLFormElement>) => {\r\n        e.preventDefault();\r\n        if (!inputHandler.isValid) {\r\n            inputHandler.setIsTouched(true);\r\n            return;\r\n        }\r\n        const columnData = {\r\n            board_uuid: boardUUID,\r\n            name: inputHandler.value!.trim(),\r\n            color: randomHexColor(),\r\n        };\r\n        fetch('/api/columns', {\r\n            method: 'POST',\r\n            headers: {\r\n                'Content-Type': 'application/json',\r\n            },\r\n            body: JSON.stringify(columnData),\r\n        }).then(() => {\r\n            inputRef.current?.blur();\r\n            inputHandler.setIsTouched(false);\r\n            inputHandler.setValue('');\r\n            mutateBoard();\r\n            mutateBoards();\r\n        });\r\n    };\r\n\r\n    return (\r\n        <div className=\"relative mt-10 w-72\">\r\n            <form\r\n                onSubmit={submitHandler}\r\n                className={`sticky top-10 flex h-[80vh] max-h-[calc(100vh-160px)] w-72 items-center justify-center rounded-md bg-gradient-to-b from-[#E9EFFA] to-[#e9effa80] text-center text-2xl font-bold text-mid-grey transition-all dark:from-[#2b2c3740] dark:to-[#2b2c3720]`}\r\n            >\r\n                <fieldset className=\"relative\">\r\n                    <input\r\n                        ref={inputRef}\r\n                        value={inputHandler.value ?? ''}\r\n                        onChange={inputHandler.valueChangeHandler}\r\n                        onBlur={inputHandler.inputBlurHandler}\r\n                        id=\"new-column\"\r\n                        type=\"text\"\r\n                        className=\"peer absolute w-56 -translate-x-1/2 bg-transparent py-1 text-center text-lg text-black caret-primary-light opacity-0 transition-all hover:outline-none focus:opacity-100 focus:outline-none dark:text-white\"\r\n                    />\r\n                    <div\r\n                        className={`absolute h-[3px] w-56 -translate-x-1/2 translate-y-10 scale-x-0 rounded transition-all peer-focus:scale-x-100 ${\r\n                            inputHandler.hasError ? 'bg-danger' : 'bg-primary '\r\n                        }`}\r\n                    />\r\n                    {inputHandler.hasError && (\r\n                        <span className=\"absolute top-12 hidden min-w-max -translate-x-1/2 text-sm text-danger peer-focus:block\">\r\n                            {inputHandler.errorMsg}\r\n                        </span>\r\n                    )}\r\n                    <label\r\n                        htmlFor=\"new-column\"\r\n                        className=\"absolute z-10 w-56 -translate-x-1/2 cursor-pointer transition-all hover:text-primary peer-focus:-translate-y-12 peer-focus:scale-75 peer-focus:text-primary\"\r\n                    >\r\n                        + New Column\r\n                    </label>\r\n                </fieldset>\r\n            </form>\r\n        </div>\r\n    );\r\n};\r\n\r\nconst Board: FC<{ boardUUID: string }> = (props) => {\r\n    const router = useRouter();\r\n    const boardData = useSWR<BoardT>(`/api/boards/${props.boardUUID}`, fetcher, {\r\n        onErrorRetry: (error) => {\r\n            if (error.status === 404 || error.status === 400) {\r\n                router.push('/');\r\n            }\r\n        },\r\n    });\r\n    const [items, setItems] = useState<Columns>({});\r\n    const [clonedItems, setClonedItems] = useState<Columns | null>(items);\r\n    const [activeId, setActiveId] = useState<UniqueIdentifier | null>(null);\r\n    const [draggedTask, setDraggedTask] = useState<Task | null>(null);\r\n\r\n    useEffect(() => {\r\n        const newValue: Columns = {};\r\n        if (!boardData.data) return;\r\n        for (const column of boardData.data.columns) {\r\n            newValue[column.name] = {\r\n                board_uuid: column.board_uuid,\r\n                uuid: column.uuid,\r\n                color: column.color,\r\n                tasks: column.tasks ?? [],\r\n            };\r\n        }\r\n        setItems(newValue);\r\n    }, [boardData.data?.columns, boardData.error]);\r\n\r\n    const mouseSensor = useSensor(MouseSensor, {\r\n        // Require the mouse to move by 10 pixels before activating\r\n        activationConstraint: {\r\n            distance: 10,\r\n        },\r\n    });\r\n    const touchSensor = useSensor(TouchSensor, {\r\n        activationConstraint: {\r\n            delay: 250,\r\n            tolerance: 10,\r\n        },\r\n    });\r\n\r\n    const sensors = useSensors(mouseSensor, touchSensor);\r\n\r\n    function findContainer(id: UniqueIdentifier, items: Columns | null) {\r\n        if (!items) return null;\r\n        if (id in items) {\r\n            return id;\r\n        }\r\n\r\n        return Object.keys(items).find((key) => items[key].tasks.some((task) => task.uuid === id));\r\n    }\r\n\r\n    function handleDragStart(event: DragStartEvent) {\r\n        const { active } = event;\r\n        const { id } = active;\r\n        const startingContainer = findContainer(id, items);\r\n        const taskObject = startingContainer && items[startingContainer].tasks.find((task) => task.uuid === id);\r\n        if (taskObject) {\r\n            setDraggedTask(taskObject);\r\n            setActiveId(id);\r\n            setClonedItems(items);\r\n        } else {\r\n            return;\r\n        }\r\n    }\r\n\r\n    function handleDragOver(event: DragOverEvent) {\r\n        const { active, over } = event;\r\n        const { id } = active;\r\n        const overId = over?.id;\r\n        if (!overId) return;\r\n\r\n        // Find the containers\r\n        const activeContainer = findContainer(id, items);\r\n        const overContainer = findContainer(overId, items);\r\n\r\n        if (!activeContainer || !overContainer || activeContainer === overContainer) {\r\n            return;\r\n        }\r\n\r\n        setItems((prev) => {\r\n            const activeItems = prev[activeContainer].tasks;\r\n            const overItems = prev[overContainer].tasks;\r\n\r\n            // Find the indexes for the items\r\n            const activeIndex = activeItems.map((task) => task.uuid as UniqueIdentifier).indexOf(id);\r\n            const overIndex = overItems.map((task) => task.uuid as UniqueIdentifier).indexOf(overId);\r\n\r\n            let newIndex;\r\n            if (overId in prev) {\r\n                // We're at the root droppable of a container\r\n                newIndex = overItems.length + 1;\r\n            } else {\r\n                const isBelowLastItem = over && overIndex === overItems.length - 1;\r\n                const modifier = isBelowLastItem ? 1 : 0;\r\n\r\n                newIndex = overIndex >= 0 ? overIndex + modifier : overItems.length + 1;\r\n            }\r\n\r\n            return {\r\n                ...prev,\r\n                [activeContainer]: {\r\n                    ...prev[activeContainer],\r\n                    tasks: [...prev[activeContainer].tasks.filter((task) => task.uuid !== active.id)],\r\n                },\r\n                [overContainer]: {\r\n                    ...prev[overContainer],\r\n                    tasks: [\r\n                        ...prev[overContainer].tasks.slice(0, newIndex),\r\n                        items[activeContainer].tasks[activeIndex],\r\n                        ...prev[overContainer].tasks.slice(newIndex, prev[overContainer].tasks.length),\r\n                    ],\r\n                },\r\n            };\r\n        });\r\n    }\r\n\r\n    function handleDragEnd(event: DragEndEvent) {\r\n        const { active, over } = event;\r\n        const { id } = active;\r\n        const overId = over?.id;\r\n        if (!overId || !clonedItems || !activeId) return;\r\n\r\n        const activeContainer = findContainer(id, items);\r\n        const overContainer = findContainer(overId, items);\r\n        const startingContainer = findContainer(activeId, clonedItems);\r\n\r\n        if (!activeContainer || !overContainer || !startingContainer) {\r\n            return;\r\n        }\r\n\r\n        const startingIndex = clonedItems[startingContainer].tasks\r\n            .map((task) => task.uuid as UniqueIdentifier)\r\n            .indexOf(activeId);\r\n        const activeIndex = items[activeContainer].tasks.map((task) => task.uuid as UniqueIdentifier).indexOf(id);\r\n        const overIndex = items[overContainer].tasks.map((task) => task.uuid as UniqueIdentifier).indexOf(overId);\r\n\r\n        if (activeIndex !== overIndex) {\r\n            setItems((items) => ({\r\n                ...items,\r\n                [overContainer]: {\r\n                    ...items[overContainer],\r\n                    tasks: arrayMove(items[overContainer].tasks, activeIndex, overIndex),\r\n                },\r\n            }));\r\n        }\r\n        if (activeId && clonedItems && draggedTask) {\r\n            const dragData = {\r\n                overIndex: overIndex !== -1 ? overIndex : items[overContainer].tasks.length - 1,\r\n                overContainer: items[overContainer].uuid,\r\n            };\r\n            // Update the task if it was moved to a different container or index\r\n            if (startingContainer === overContainer && startingIndex === overIndex) {\r\n                boardData.mutate();\r\n            } else {\r\n                fetch(`/api/tasks/${draggedTask.uuid}`, {\r\n                    method: 'PUT',\r\n                    headers: {\r\n                        'Content-Type': 'application/json',\r\n                    },\r\n                    body: JSON.stringify({\r\n                        column_uuid: dragData.overContainer,\r\n                        position: dragData.overIndex,\r\n                    }),\r\n                }).then(() => {\r\n                    boardData.mutate();\r\n                });\r\n            }\r\n        }\r\n        setClonedItems(null);\r\n        setActiveId(null);\r\n    }\r\n\r\n    return (\r\n        <section className=\"grid h-full w-fit auto-cols-min grid-flow-col gap-6\">\r\n            <DndContext\r\n                sensors={sensors}\r\n                measuring={{\r\n                    droppable: {\r\n                        strategy: MeasuringStrategy.Always,\r\n                    },\r\n                }}\r\n                collisionDetection={closestCorners}\r\n                onDragStart={handleDragStart}\r\n                onDragOver={handleDragOver}\r\n                onDragEnd={handleDragEnd}\r\n            >\r\n                {items &&\r\n                    Object.entries(items).map(([colName, colData]) => {\r\n                        return <Column key={colName} name={colName} columnData={colData} />;\r\n                    })}\r\n                {boardData.data && <NewColumnBar boardUUID={boardData.data.uuid} mutateBoard={boardData.mutate} />}\r\n            </DndContext>\r\n        </section>\r\n    );\r\n};\r\n\r\nexport default Board;"
        }
    ]
}